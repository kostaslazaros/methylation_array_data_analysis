# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = seur_data.list)
ad.anchors <- FindIntegrationAnchors(object.list = seur_data.list, anchor.features = features)
# this command creates an 'integrated' data assay k.weight = 30
ad.combined <- IntegrateData(anchorset = ad.anchors)
DefaultAssay(ad.combined) <- "integrated"
ad.combined <- ScaleData(ad.combined, verbose = FALSE)
ad.combined <- RunPCA(ad.combined, npcs = 30, verbose = FALSE)
ElbowPlot(ad.combined)
ad.combined <- RunUMAP(ad.combined, reduction = "pca", dims = 1:10)
ad.combined <- FindNeighbors(ad.combined, reduction = "pca", dims = 1:10)
ad.combined <- FindClusters(ad.combined, resolution = 0.5)
p1 <- DimPlot(ad.combined, reduction = "umap", group.by = "patient") + ggtitle('Batch')
p2 <- DimPlot(ad.combined, reduction = "umap", group.by = "predicted.id") + ggtitle('Cell-types')
p1
p2
ad.combined
saveRDS(ad.combined, file = output_path)
gc()
library(tools)
library(Seurat)
library(SeuratData)
library(SeuratDisk)
rds_dir <- "./data/rds/integrated/"
files <-list.files(rds_dir,  pattern = "\\.rds$")
files <- list.files(rds_dir, pattern = "$_CCA_integration$")
files <- list.files(rds_dir, pattern = "$_CCA_integration$")
files <-list.files(rds_dir,  pattern = "\\.rds$")
clean_names <- lapply(files, file_path_sans_ext)
clean_names
for (file in clean_names) {
rds_file <- paste(file, "rds", sep=".")
rds_path <- paste(rds_dir, rds_file, sep = "")
h5seurat_file <- paste(file, "h5Seurat", sep=".")
h5seurat_path <- paste("./", h5seurat_file, sep = "")
data <- readRDS(rds_path)
SaveH5Seurat(data, filename = h5seurat_path)
Convert(h5seurat_path, dest = "h5ad")
file.remove(h5seurat_path)
}
gc()
gc()
gc()
setwd("~/prj/souzana_methylation_array_project")
# Load all necessary packages
library(limma)
library(minfi)
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
library(IlluminaHumanMethylationEPICmanifest)
library(RColorBrewer)
library(missMethyl)
library(minfiData)
library(Gviz)
library(DMRcate)
library(stringr)
library(reshape)
library(lattice)
library(Matrix)
library(data.table)
library(dplyr)
# get the EPIC annotation data
annEPIC <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
head(annEPIC)
# read in the sample sheet for the experiment
targets <- read.metharray.sheet("./step01_epic4dmp_benign_vs_indolent", pattern="SampleSheet.csv")
targets
# get the EPIC annotation data
annEPIC <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
head(annEPIC)
# read in the sample sheet for the experiment
targets <- read.metharray.sheet("./step01_epic4dmp_benign_vs_indolent", pattern="SampleSheet.csv")
targets
# read in the raw data from the IDAT files
rgSet <- read.metharray.exp(targets=targets, force = TRUE)
rgSet
# give the samples descriptive names
targets$ID <- paste(targets$Prognosis_full,targets$Sample_Name,sep=".")
sampleNames(rgSet) <- targets$ID
rgSet
# calculate the detection p-values
detP <- detectionP(rgSet)
head(detP)
pal <- brewer.pal(8,"Dark2")
# Generate the barplot and capture its return value for use with legend placement
par(mfrow=c(1,1))
bp <- barplot(colMeans(detP), col = pal[factor(targets$Prognosis_simple)], las = 2,
cex.names = 0.8, ylab = "Mean detection p-values")
legend("topleft", legend = levels(factor(targets$Prognosis_simple)), fill = pal, bg = "white")
legend("topleft", legend = levels(factor(targets$Prognosis_simple)), fill = pal, bg = "white")
.isRGOrStop <- function(object) {
if (!is(object, "RGChannelSet")) {
stop("object is of class '", class(object), "', but needs to be of ",
"class 'RGChannelSet' or 'RGChannelSetExtended'")
}
}
mycontrolStripPlot <- function(rgSet,
controls = c("BISULFITE CONVERSION I",
"BISULFITE CONVERSION II"),
sampNames = NULL, xlim = c(5, 17)) {
.isRGOrStop(rgSet)
r <- getRed(rgSet)
g <- getGreen(rgSet)
for (controlType in controls) {
ctrlAddress <- getControlAddress(rgSet, controlType = controlType)
# Red channel
ctlWide <- as.matrix(log2(r[ctrlAddress, ,drop=FALSE]))
if (!is.null(sampNames)) colnames(ctlWide) <- sampNames
ctlR <- melt(ctlWide, varnames = c("address", "sample"))
# Green channel
ctlWide <- as.matrix(log2(g[ctrlAddress, ,drop=FALSE]))
if (!is.null(sampNames)) colnames(ctlWide) <- sampNames
ctlG <- melt(ctlWide, varnames = c("address", "sample"))
# Plot
ctl <- rbind(
cbind(channel = "Red", ctlR),
cbind(channel = "Green", ctlG))
if (any((ctl$value < xlim[1]) | (ctl$value > xlim[2]))) {
message("Warning: ", controlType, " probes outside plot range")
}
fig <- xyplot(
x = sample ~ value | channel,
groups = channel, horizontal = TRUE, pch = 19,
col = c("darkgreen", "darkred"),
xlab = "Log2 Intensity",
xlim = xlim,
main = paste("Control:", controlType),
layout = c(2, 1),
data = ctl,
panel = function(x, y,...) {
panel.stripplot(x, y,...)
panel.abline(h = (as.numeric(y) - 0.5), lty = 3, col = "grey70")
})
print(fig)
}
}
mycontrolStripPlot(rgSet, "BISULFITE CONVERSION II")
# remove poor quality samples
keep <- colMeans(detP) < 0.05
rgSet <- rgSet[,keep]
rgSet
# remove poor quality samples from targets data
targets <- targets[keep,]
# remove poor quality samples from detection p-value table
detP <- detP[,keep]
dim(detP)
# normalize the data; this results in a GenomicRatioSet object
mSetSq <- preprocessFunnorm(rgSet)
# create a MethylSet object from the raw data for plotting
mSetRaw <- preprocessRaw(rgSet)
qc <- getQC(mSetRaw)
plotQC(qc)
# visualise what the data looks like before and after normalisation
par(mfrow=c(1,2))
densityPlot(rgSet, sampGroups=targets$Prognosis_simple,main="Raw", legend=FALSE)
legend("top", legend = levels(factor(targets$Prognosis_simple)),
text.col=brewer.pal(8,"Dark2"))
densityPlot(getBeta(mSetSq), sampGroups=targets$Prognosis_simple,
main="Normalized", legend=FALSE)
legend("top", legend = levels(factor(targets$Prognosis_simple)),
text.col=brewer.pal(8,"Dark2"))
# MDS plots to look at largest sources of variation
par(mfrow=c(1,1))
plotMDS(getM(mSetSq), top=1000, gene.selection="common",
col=pal[factor(targets$Prognosis_simple)])
legend("topleft", legend=levels(factor(targets$Prognosis_simple)), text.col=pal,
bg="white", cex=0.7)
# ensure probes are in the same order in the mSetSq and detP objects
detP <- detP[match(featureNames(mSetSq),rownames(detP)),]
# remove any probes that have failed in one or more samples
keep <- rowSums(detP < 0.01) == ncol(mSetSq)
table(keep)
mSetSqFlt <- mSetSq[keep,]
mSetSqFlt
# remove probes with SNPs at CpG site
mSetSqFlt <- dropLociWithSnps(mSetSqFlt)
mSetSqFlt
# exclude cross reactive probes
xReactiveProbes <- maxprobes::xreactive_probes(array_type = "EPIC")
xReactiveProbes <- unlist(xReactiveProbes)
keep2 <- !(featureNames(mSetSqFlt) %in% xReactiveProbes)
table(keep2)
mSetSqFlt <- mSetSqFlt[keep2,]
mSetSqFlt
# MDS plots to look at largest sources of variation
par(mfrow=c(1,1))
plotMDS(getM(mSetSqFlt), top=1000, gene.selection="common",
col=pal[factor(targets$Batch)])
legend("topleft", legend=levels(factor(targets$Batch)), text.col=pal,
bg="white", cex=0.7)
# MDS plots to look at largest sources of variation
par(mfrow=c(1,1))
plotMDS(getM(mSetSqFlt), top=1000, gene.selection="common",
col=pal[factor(targets$Prognosis_simple)])
legend("topleft", legend=levels(factor(targets$Prognosis_simple)), text.col=pal,
bg="white", cex=0.7)
# calculate M-values for statistical analysis
mVals <- getM(mSetSqFlt)
head(mVals[,1:5])
bVals <- getBeta(mSetSqFlt)
# Convert the matrix to a data frame
bVals_df <- as.data.frame(bVals)
head(bVals[,1:5])
par(mfrow=c(1,2))
densityPlot(bVals, sampGroups=targets$Prognosis_simple, main="Beta values",
legend=FALSE, xlab="Beta values")
legend("topright", legend = levels(factor(targets$Prognosis_simple)),
text.col=brewer.pal(8,"Dark2"))
densityPlot(mVals, sampGroups=targets$Prognosis_simple, main="M-values",
legend=FALSE, xlab="M values")
legend("topleft", legend = levels(factor(targets$Prognosis_simple)),
text.col=brewer.pal(8,"Dark2"))
# this is the factor of interest
prognosis <- factor(targets$Prognosis_simple)
# use the above to create a design matrix
design <- model.matrix(~0+prognosis, data=targets)
colnames(design) <- c(levels(prognosis))
# fit the linear model
fit1 <- lmFit(mVals, design)
# create a contrast matrix for specific comparisons
contMatrix <- makeContrasts(indolent-benign, levels=design)
# fit the contrasts
fit2 <- contrasts.fit(fit1, contMatrix)
fit2 <- eBayes(fit2)
# look at the numbers of DM CpGs at FDR < 0.05
summary(decideTests(fit2))
# get the table of results for the first contrast (naive - rTreg)
annEPICSub <- annEPIC[match(rownames(mVals),annEPIC$Name),
c(1:4,12:19,24:ncol(annEPIC))]
DMPs <- topTable(fit2, num=Inf, coef=1, genelist=annEPICSub)
head(DMPs)
write.table(DMPs, file="./step01_indolent_vs_benign_DMPs.csv", sep=",", row.names=FALSE)
# Differentially methylated regions
myAnnotation <- cpg.annotate(object = mVals, datatype = "array", what = "M",
analysis.type = "differential", design = design,
contrasts = TRUE, cont.matrix = contMatrix,
coef = "indolent - benign", arraytype = "EPIC")
str(myAnnotation)
DMRs <- dmrcate(myAnnotation, lambda=1000, pcutoff = 0.001)
results.ranges <- extractRanges(DMRs)
results.ranges
# Save the GRanges object
saveRDS(results.ranges, file = "./step01_indolent_vs_benign_granges_object.rds")
# set up the grouping variables and colours
groups <- pal[1:length(unique(targets$Prognosis_simple))]
names(groups) <- levels(factor(targets$Prognosis_simple))
cols <- groups[as.character(factor(targets$Prognosis_simple))]
# draw the plot for the top DMR
par(mfrow=c(1,1))
DMR.plot(ranges = results.ranges, dmr = 22, CpGs = bVals, phen.col = cols,
what = "Beta", arraytype = "EPIC", genome = "hg19")
DMR.plot(ranges = results.ranges, dmr = 18, CpGs = bVals, phen.col = cols,
what = "Beta", arraytype = "EPIC", genome = "hg19")
library(lattice)
manhattan.plot<-function(chr, pos, pvalue,
sig.level=NA, annotate=NULL, ann.default=list(),
should.thin=T, thin.pos.places=2, thin.logp.places=2,
xlab="Chromosome", ylab=expression(-log[10](p-value)),
col=c("gray","darkgray"), panel.extra=NULL, pch=20, cex=0.8,...) {
if (length(chr)==0) stop("chromosome vector is empty")
if (length(pos)==0) stop("position vector is empty")
if (length(pvalue)==0) stop("pvalue vector is empty")
#make sure we have an ordered factor
if(!is.ordered(chr)) {
chr <- ordered(chr)
} else {
chr <- chr[,drop=T]
}
#make sure positions are in kbp
if (any(pos>1e6)) pos<-pos/1e6;
#calculate absolute genomic position
#from relative chromosomal positions
posmin <- tapply(pos,chr, min);
posmax <- tapply(pos,chr, max);
posshift <- head(c(0,cumsum(posmax)),-1);
names(posshift) <- levels(chr)
genpos <- pos + posshift[chr];
getGenPos<-function(cchr, cpos) {
p<-posshift[as.character(cchr)]+cpos
return(p)
}
#parse annotations
grp <- NULL
ann.settings <- list()
label.default<-list(x="peak",y="peak",adj=NULL, pos=3, offset=0.5,
col=NULL, fontface=NULL, fontsize=NULL, show=F)
parse.label<-function(rawval, groupname) {
r<-list(text=groupname)
if(is.logical(rawval)) {
if(!rawval) {r$show <- F}
} else if (is.character(rawval) || is.expression(rawval)) {
if(nchar(rawval)>=1) {
r$text <- rawval
}
} else if (is.list(rawval)) {
r <- modifyList(r, rawval)
}
return(r)
}
if(!is.null(annotate)) {
if (is.list(annotate)) {
grp <- annotate[[1]]
} else {
grp <- annotate
}
if (!is.factor(grp)) {
grp <- factor(grp)
}
} else {
grp <- factor(rep(1, times=length(pvalue)))
}
ann.settings<-vector("list", length(levels(grp)))
ann.settings[[1]]<-list(pch=pch, col=col, cex=cex, fill=col, label=label.default)
if (length(ann.settings)>1) {
lcols<-trellis.par.get("superpose.symbol")$col
lfills<-trellis.par.get("superpose.symbol")$fill
for(i in 2:length(levels(grp))) {
ann.settings[[i]]<-list(pch=pch,
col=lcols[(i-2) %% length(lcols) +1 ],
fill=lfills[(i-2) %% length(lfills) +1 ],
cex=cex, label=label.default);
ann.settings[[i]]$label$show <- T
}
names(ann.settings)<-levels(grp)
}
for(i in 1:length(ann.settings)) {
if (i>1) {ann.settings[[i]] <- modifyList(ann.settings[[i]], ann.default)}
ann.settings[[i]]$label <- modifyList(ann.settings[[i]]$label,
parse.label(ann.settings[[i]]$label, levels(grp)[i]))
}
if(is.list(annotate) && length(annotate)>1) {
user.cols <- 2:length(annotate)
ann.cols <- c()
if(!is.null(names(annotate[-1])) && all(names(annotate[-1])!="")) {
ann.cols<-match(names(annotate)[-1], names(ann.settings))
} else {
ann.cols<-user.cols-1
}
for(i in seq_along(user.cols)) {
if(!is.null(annotate[[user.cols[i]]]$label)) {
annotate[[user.cols[i]]]$label<-parse.label(annotate[[user.cols[i]]]$label,
levels(grp)[ann.cols[i]])
}
ann.settings[[ann.cols[i]]]<-modifyList(ann.settings[[ann.cols[i]]],
annotate[[user.cols[i]]])
}
}
rm(annotate)
#reduce number of points plotted
if(should.thin) {
thinned <- unique(data.frame(
logp=round(-log10(pvalue),thin.logp.places),
pos=round(genpos,thin.pos.places),
chr=chr,
grp=grp)
)
logp <- thinned$logp
genpos <- thinned$pos
chr <- thinned$chr
grp <- thinned$grp
rm(thinned)
} else {
logp <- -log10(pvalue)
}
rm(pos, pvalue)
gc()
#custom axis to print chromosome names
axis.chr <- function(side,...) {
if(side=="bottom") {
panel.axis(side=side, outside=T,
at=((posmax+posmin)/2+posshift),
labels=levels(chr),
ticks=F, rot=90,
check.overlap=F
)
} else if (side=="top" || side=="right") {
panel.axis(side=side, draw.labels=F, ticks=F);
}
else {
axis.default(side=side,...);
}
}
#make sure the y-lim covers the range (plus a bit more to look nice)
prepanel.chr<-function(x,y,...) {
A<-list();
maxy<-ceiling(max(y, ifelse(!is.na(sig.level), -log10(sig.level), 0)))+.5;
A$ylim=c(0,maxy);
A;
}
xyplot(logp~genpos, chr=chr, groups=grp,
axis=axis.chr, ann.settings=ann.settings,
prepanel=prepanel.chr, scales=list(axs="i"),
panel=function(x, y, ..., getgenpos) {
if(!is.na(sig.level)) {
#add significance line (if requested)
panel.abline(h=-log10(sig.level), lty=2);
}
panel.superpose(x, y, ..., getgenpos=getgenpos);
if(!is.null(panel.extra)) {
panel.extra(x,y, getgenpos, ...)
}
},
panel.groups = function(x,y,..., subscripts, group.number) {
A<-list(...)
#allow for different annotation settings
gs <- ann.settings[[group.number]]
A$col.symbol <- gs$col[(as.numeric(chr[subscripts])-1) %% length(gs$col) + 1]
A$cex <- gs$cex[(as.numeric(chr[subscripts])-1) %% length(gs$cex) + 1]
A$pch <- gs$pch[(as.numeric(chr[subscripts])-1) %% length(gs$pch) + 1]
A$fill <- gs$fill[(as.numeric(chr[subscripts])-1) %% length(gs$fill) + 1]
A$x <- x
A$y <- y
do.call("panel.xyplot", A)
#draw labels (if requested)
if(gs$label$show) {
gt<-gs$label
names(gt)[which(names(gt)=="text")]<-"labels"
gt$show<-NULL
if(is.character(gt$x) | is.character(gt$y)) {
peak = which.max(y)
center = mean(range(x))
if (is.character(gt$x)) {
if(gt$x=="peak") {gt$x<-x[peak]}
if(gt$x=="center") {gt$x<-center}
}
if (is.character(gt$y)) {
if(gt$y=="peak") {gt$y<-y[peak]}
}
}
if(is.list(gt$x)) {
gt$x<-A$getgenpos(gt$x[[1]],gt$x[[2]])
}
do.call("panel.text", gt)
}
},
xlab=xlab, ylab=ylab,
panel.extra=panel.extra, getgenpos=getGenPos, ...
);
}
df <- read.csv("./step01_indolent_vs_benign_DMPs.csv", header = TRUE, sep = ",", quote = "\"", stringsAsFactors = FALSE)
# Assuming your data frame is named df
df <- subset(df, P.Value < 0.01)
# Adjust the factor levels to match the 'chr' prefix format and include 'chrY'
df$chr <- factor(df$chr, levels = c(paste0("chr", 1:22), "chrX", "chrY"))
# Initialize an annotation vector with empty strings
ann <- rep("", nrow(df))
# Identify significant CpG sites
significant_sites <- which(df$P.Value < 1e-5)
# Annotate the significant CpG sites with their names
ann[significant_sites] <- as.character(df$Name[significant_sites])
# Convert the annotation vector into a factor, which will be used in the plot
ann <- factor(ann)
# Now call your manhattan.plot function with the adjusted chromosome column
manhattan.plot(df$chr, df$pos, df$P.Value, annotate= ann)
library(tidyverse)
library(RColorBrewer)
library(ggrepel)
df <- read.csv("./step01_indolent_vs_benign_DMPs.csv")
df$neg_log10_pval <- -log10(df$P.Value)
df
# Biostatsquid theme
theme_set(theme_classic(base_size = 20) +
theme(
axis.title.y = element_text(face = "bold", margin = margin(0,20,0,0), size = rel(1.1), color = 'black'),
axis.title.x = element_text(hjust = 0.5, face = "bold", margin = margin(20,0,0,0), size = rel(1.1), color = 'black'),
plot.title = element_text(hjust = 0.5)
))
# Add a column to the data frame to specify if they are UP- or DOWN- regulated (log2fc respectively positive or negative)<br /><br /><br />
df$diffexpressed <- "NO"
df$diffexpressed[df$logFC > 1 & df$P.Value < 0.001] <- "UP"
df$diffexpressed[df$logFC < -1 & df$P.Value < 0.001] <- "DOWN"
head(df[order(df$P.Value) & df$diffexpressed == 'DOWN', ])
# df_annotated <- df[df$genes %in% genes_to_annotate,]
# For Downregulated genes: prioritize by -log10(pval) first (high significance), then by logfoldchanges (most negative)
top_downregulated <- df[df$diffexpressed == "DOWN", ][order(-df$neg_log10_pval[df$diffexpressed == "DOWN"], df$logFC[df$diffexpressed == "DOWN"]), ][1:5,]
top_upregulated <- df[df$diffexpressed == "UP", ][order(-df$neg_log10_pval[df$diffexpressed == "UP"], -df$logFC[df$diffexpressed == "UP"]), ][1:5,]
# Combine into a list
top_dmps_combined <- c(top_downregulated$Name, top_upregulated$Name)
top_dmps_combined
df_annotated <- df[df$Name %in% top_dmps_combined,]
# Note. with coord_cartesian() even if we have genes with p-values or log2FC ourside our limits, they will still be plotted.
# Your adjusted plot code
p <- ggplot(data=df, aes(x=logFC, y= -log10(P.Value), col=diffexpressed)) +
geom_vline(xintercept=c(-1, 1), col = "gray", linetype = 'dashed') +
geom_hline(yintercept=-log10(0.001), col = "gray", linetype = 'dashed') +
geom_point(size=2) +
scale_color_manual(values=c("#00AFBB", "grey", "#bb0c00"),
labels=c("Hypomethylated", "Not significant", "Hypermethylated")) +
coord_cartesian(ylim=c(0, 11), xlim=c(-7, 7)) +
labs(color='', x=expression("log"[2]*"FC"), y=expression("-log"[10]*"p-value")) +
scale_x_continuous(breaks=seq(-7, 7, 1)) +
ggtitle("GSE227814 DMPs (Metastasis vs Benign)")
# Adding labels with ggrepel for better visibility and avoiding overlaps
p + geom_label_repel(data=df_annotated, aes(label=Name, x=logFC, y= -log10(P.Value)),
box.padding=0.35, point.padding = 0.5,
size=3, segment.color='grey50', show.legend=FALSE)
# Note. with coord_cartesian() even if we have genes with p-values or log2FC ourside our limits, they will still be plotted.
# Your adjusted plot code
p <- ggplot(data=df, aes(x=logFC, y= -log10(P.Value), col=diffexpressed)) +
geom_vline(xintercept=c(-1, 1), col = "gray", linetype = 'dashed') +
geom_hline(yintercept=-log10(0.001), col = "gray", linetype = 'dashed') +
geom_point(size=2) +
scale_color_manual(values=c("#00AFBB", "grey", "#bb0c00"),
labels=c("Hypomethylated", "Not significant", "Hypermethylated")) +
coord_cartesian(ylim=c(0, 11), xlim=c(-7, 7)) +
labs(color='', x=expression("log"[2]*"FC"), y=expression("-log"[10]*"p-value")) +
scale_x_continuous(breaks=seq(-7, 7, 1)) +
ggtitle("DMPs (Indolent vs Benign)")
# Adding labels with ggrepel for better visibility and avoiding overlaps
p + geom_label_repel(data=df_annotated, aes(label=Name, x=logFC, y= -log10(P.Value)),
box.padding=0.35, point.padding = 0.5,
size=3, segment.color='grey50', show.legend=FALSE)
ggsave("./step01_volcano_indolent_benign.png", dpi = 600)
